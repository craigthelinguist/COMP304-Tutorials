\documentclass[a4paper,12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage{listings}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{let,if,then,else}}
\lstloadlanguages{Java, Haskell}

% Key word, key word adjacent.
\newcommand{\kwa}[1]{\mathtt{#1}}
\newcommand{\kw}[1]{\kwa{#1}~}

\begin{document}

\title{COMP304 Tutorial 6 \\ 19/08/2016}
\date{}
\maketitle


\section{Programming Languages}

\noindent
In assignment 3 you will be implementing a programming language, a virtual machine, a compiler, and an interpreter. We'll cover those concepts in this section. \\

\noindent
When you write a program, compile it, then execute it, the process usually happens in a sequence of steps: parsing $\rightarrow$ static analysis $\rightarrow$ compiling $\rightarrow$ execution. \\

\noindent
\textbf{1. Parsing.} This takes source code e.g. a $\kwa{.java}$ file or a $\kwa{.lhs}$ file and turns it into an abstract syntax tree (AST). The AST is a tree representation of the structure and control flow of the program. \\

\noindent
In the Straight-line programming language we'll be working with, source code like this:

\begin{lstlisting}[language=Haskell]
x := 5;
y := x + 2;
\end{lstlisting}

\noindent
Would be represented by the following AST in $\kwa{Straight.lhs}$:

\begin{lstlisting}[language=Haskell]
[Asgn x (Const 5), Asgn y (Bin Plus x (Const 2))]
\end{lstlisting}

\noindent
In the assignment we do $\textbf{not}$ bother with source code or parsing; you'll start working directly with the AST representation of programs. \\

\noindent
$\textbf{2. Static Analysis.}$ We take the AST and check various safety properties. For instance, that it is well-typed (you never add booleans and ints; you never use a variable before it is declared). The version of $\kwa{Straight.lhs}$ only has the  $\kwa{Int}$ type and does not static checking; your goal in part 2 will be to enrich the language with more types, and ensure it is type-safe and declaration-safe. \\

\noindent
$\textbf{3. Compilation.}$ Once the AST has passed our static analysis we translate it into a program in a lower-level language. The target language is sometimes called ``the object language''. \\

\noindent
In the case of Java, the object-language is Java bytecode. If you're programming in C on x86 architecture, the object-language will be x86 assembly. In our assignment the object-language will be our own stack-based language. Sometimes languages compile to another language, e.g. Python to C (via Cython). \\

\noindent
$\textbf{4. Execution.}$ When the program has been compiled into object code we may wish to execute it. Execution may happen directly at the CPU (if we've e.g. compiled to assembly) or it may happen by running our code through an interpreter for the object code. The former is how programs in C would be executed; the latter is how programs in Java would be executed on a Java virtual machine. \\

\noindent
We will be writing an interpreter for our stack-based language. Our straight-line ASTs will be compiled into object code for our stack-based language, and then executed by our interpreter. \\

\section{Stack-Based Language}

\noindent
A stack-based language is one in which the majority of logic, computation, and control-flow happens through the manipulation of values on a stack. This is how most assembly languages and virtual machine languages work (including x86 asm and Java bytecode). \\

\noindent
There are usually other notions of memory, such as the heap or registers. In our language we split memory into the stack (short-term memory) and store (long-term memory). The stack is represented as a list of $\kwa{Int}$; when you do part 2 you will have to generalise this to a list of e.g. $\kwa{StackVal}$, where a $\kwa{StackVal}$ is either a $\kwa{Bool}$ or an $\kwa{Int}$. The store is represented as a list of pairs of variables and values. \\

\noindent
The program of a Stack-based languages is a list of commands. There are four commands in $\kwa{Straight.lhs}$, which are as follows.

\begin{itemize}
	\item $\kwa{LoadI~x}$. Pushes the integer constant $\kwa{x}$ onto the stack.
	\item $\kwa{Load~v}$. Retrieves the value $\kwa{y}$ associated with variable $\kwa{v}$ in the store and pushes it onto the stack.
	\item $\kwa{Store~v}$. Updates variable $\kwa{v}$ to have the value of whatever is on top of the stack. The value on top of the stack is then popped.
	\item $\kwa{BinOp~op}$. Performs the arithmetic operation $\kwa{op}$ to the two values on top of the stack. The values are then popped, and the result of the operation is pushed onto the stack.	
\end{itemize}

\noindent
Let's take the stack $\kwa{[1,2,3]}$ and the store $\kwa{[(`v', 5)]}$. Here are some examples of how each of the commands above would affect the stack and store (note that an operation might leave the stack or store unchanged).

\begin{itemize}
	\item $\kwa{LoadI~0}$ would produce stack $\kwa{[0,1,2,3]}$ and store $\kwa{[(`v', 5)]}$.
	\item $\kwa{Load~v}$ would produce stack $\kwa{[5,1,2,3]}$ and store $\kwa{[(`v', 5)]}$.
	\item $\kwa{Store~v}$ would produce stack $\kwa{[2,3]}$ and store $\kwa{[(`v', 1)]}$.
	\item $\kwa{Store~y}$ would produce stack $\kwa{[2,3]}$ and store $\kwa{[(`v', 5), (`y', 1)]}$.
	\item $\kwa{BinOp~Plus}$ would produce stack $\kwa{[3,3]}$ and store $\kwa{[(`v', 5)]}$.
	\item $\kwa{BinOp~Minus}$ would produce stack $\kwa{[-1, 3]}$ and store $\kwa{[(`v', 5)]}$. 
\end{itemize}

\noindent
If you run into a problem applying a command (e.g. you load a non-existent variable) then your stack program should crash.

\section{Translating Expressions}

\noindent
The implementation in $\kwa{Straight.lhs}$ already translates assignments and expressions. It's worth expounding a little on how that works. \\

\noindent
An integer constant translates directly into a $\kwa{LoadI}$ instruction. For example, the expression $5$ in a straight-line program will be turned into the following stack program:

\begin{lstlisting}[language=Haskell]
LoadI 5
\end{lstlisting}

\noindent
To translate a compound expression, like $\kwa{LHS~+~RHS}$, we must first translate the sub-expressions $\kwa{LHS}$ and $\kwa{RHS}$, and then add a $\kwa{BinOp~Plus}$ instruction afterwards. For example, an expression like $3+2$ in source code, which would have an AST like $\kwa{Bin~Plus~(Const~3)~(Const~2)}$, should translate into:

\begin{lstlisting}[language=Haskell]
LoadI 3
LoadI 2
BinOp Plus
\end{lstlisting}

\noindent
If our expression is a variable, we turn that into the appropriate $\kwa{Load}$ instruction. Because our description of how to translate expressions is recursive, it immediately works on more complicated expressions. An expression like $\kwa{3+2*x}$ in source code, which would have an AST like $\kwa{Bin~Plus~(Const 3)~(Bin~Times~(Const~2)~x)}$, would translate into the following stack program:

\begin{lstlisting}[language=Haskell]
LoadI 3
LoadI 2
Load x
BinOp Times
BinOp Plus
\end{lstlisting}

\noindent
You should read through $\kwa{Straight.lhs}$ and verify that expressions are translated in this way.

\section{Translating Statements}

\noindent
A straight-line program is a list of statements. The only kind of statement in $\kwa{Straight.lhs}$ is an assignment statement. A straight-line program consisting of a single assignment like this:

\begin{lstlisting}
x := 3
\end{lstlisting}

\noindent
Would have this AST: $\kwa{[Asgn~x~(Const~3)]}$. To translate a list of statements, we translate each into its stack-language commands, and then concatenate the results into a big list of all the commands which make up our program. \\

\noindent
To translate the statement $\kwa{Asgn~x~(Const~3)}$, we must first translate the expression and then add a $\kwa{Load~x}$ command afterwards. Our program above would turn into the following stack code:

\begin{lstlisting}
LoadI 3
Store x
\end{lstlisting}

\noindent
If we had straight-line source code consisting of several assignments, like so:

\begin{lstlisting}
x := 5
x := 2 * x
y := x + 1
\end{lstlisting}

\noindent
The straight-line AST would be: $\kwa{[Asgn~x~(Const~5), Asgn~x~(Bin~Times~(Const~2)~x),}$\\$\kwa{Asgn~y~(Bin~Plus~x~(Const~1))]}$.
It's stack code will end up being the following (note the comments would not actually be there, they are just added by me for clarity):


\begin{lstlisting}
-- this is the code for x := 5
LoadI 5
Store x
-- this is the code for x := 2 * x
LoadI 2
Load x
BinOp Times
Store x
-- this is the code for y := x + 1
Load x
LoadI 1
BinOp Plus
Store y
\end{lstlisting}

\noindent
Again, you should read $\kwa{Straight.lhs}$ and make sure you understand how the translation of assignment statements works.

\section{Jumps, LessThan, NoOp}

\noindent
In part 1 you are to add if-statements and while-loops to the straight-line language, and add code to translate those into stack code. At the moment the four commands of our stack-based language are not rich enough to be able to express control-flow structures like loops and conditionals. In computability terms, it's not yet Turing complete (it cannot express all programs). \\

\noindent
The way we will make our language Turing complete is to add a $\kwa{Jump}$ command (also called $\kwa{Goto}$). Clever use of $\kwa{Jump}$ is all we need to translate loops and conditionals. $\kwa{Jump~i}$ specifies that $\kwa{i}$ should be the next command to be executed, where $\kwa{i}$ an index/line number into the code. \\

\noindent
Usually we have two kinds of $\kwa{Jump}$; one is conditional (depending on the value on top of the stack) and the other jumps no matter what. We actually only need conditional jumps, but for the sake of human readability we'll define both commands Because we need to compare integers for part 1, we'll add the binary operation $\kwa{LessThan}$. \\

\begin{itemize}
	\item $\kwa{Jump~i}$. Jump to line $i$ in the commands.
	\item $\kwa{JumpEqZ~i}$. If the value on top of the stack is equal to $0$, jump to line $i$. Otherwise do nothing and move to the next line.
	\item $\kwa{LessThan}$. If the first value on the stack is less than the second value on the stack, push a 1 on the stack and throw the two values away. Otherwise push a 0 on the stack and throw the two values away.
\end{itemize}

\noindent
In this way we're using $\kwa{Int}$ values to simulate booleans, C-style. $1$ is $\kwa{True}$ and $0$ is $\kwa{False}$ (usually, any non-zero is considered $\kwa{True}$). In part 2 you'll be adding a true boolean type. It's up to you if you want to change how your $\kwa{Jump}$ commands to work only on $\kwa{Bool}$ values on the stack. \\

\noindent
The last command we need is $\kwa{NoOp}$. We'll see why in a moment. $\kwa{NoOp}$ does absolutely nothing! \\


\section{Translating If-Statements}

\noindent
Imagine we had source code like this:

\begin{lstlisting}
if (0 < 1) then { x := 1 } else { x := 0 }
\end{lstlisting}

\noindent
I'm not telling you what the AST will look like (your goal is to come up with something appropriate), but the stack code should look something like this:

\begin{lstlisting}
LoadI 0
LoadI 1
BinOp LessThan
JumpEqZ 8 -- if false jump to false branch
LoadI 1
Store x
Jump 10 -- jump to end of conditional
LoadI 0
Store x
NoOp
\end{lstlisting}

\noindent
Lines $1 -3$ are performing the $0 < 1$ check. After this, a value $1$ or $0$ will be on the stack. Line $4$ checks that value. If it is $0/\kwa{False}$ then we jump to the false branch, which is lines $8 - 9$. Then we fall through to the end of the code (marked by $\kwa{NoOp}$ on line $10$). If the conditional jump fails, control falls through to the true branch on lines $5 - 7$. The jump on line $7$ takes us to the end of the conditional; if we didn't have it, after executing the true branch our code would fall through to the false branch! \\

\noindent 
This is also the reason why we need a $\kwa{NoOp}$. If we only had lines $1 - 9$, and this if-statement was the last thing in our program, there'd be no line $10$ to jump to. Line $7$ would then be a runtime error. $\kwa{NoOp}$ is needed to pad out the program.\\

\noindent
Observation: since $0 < 1$ is always true we could generate more efficient code by replacing this entire expression with the false branch (since that is the branch that will always get executed). Doing this is fine, but complicates the logic of translation and not expected for the duration of the assignment. \\

\noindent
The general strategy for translating a conditional:

\begin{enumerate}
	\item Translate the condition
	\item If result is $0$, jump to false branch
	\item Translate true branch
	\item Add a jump to exit
	\item Translate false branch
	\item Add a NoOp (to signify exit)
\end{enumerate}


\noindent
In part 1 you're going to have to add these extra commands, implement their run-time behaviour, add an AST representation for loops and conditionals, and implement the translation of loops and conditionals into stack commands. Translation of while loops is done in a similar way to translation of if-statements (hint: you're allowed to jump backwards, not just forwards).

\section{Symbolic Jumps}

There's a book-keeping issue in translating conditionals: we don't know in advance how big the code for each branch will be. Therefore we aren't going to know exactly what line to jump to. \\

\noindent
The solution for this is to allow for symbolic labels in code, and jumps to symbolic labels. This requires three extra commands.

\begin{itemize}
	\item $\kwa{Label~x}$. Does nothing when executed.
	\item $\kwa{LJump~l}$. Jump to label $\kwa{l}$.
	\item $\kwa{LJumpEqZ~l}$. Jump to label $\kwa{l}$, if the value on top of the stack is $0$. Otherwise move to next line.
\end{itemize}

\noindent
To solve the problem of not knowing the destination for jumps, programs are translated in two-stages. In the first stage we use symbolic jumps and labels. Once we've generated the code with symbolic jumps, we know the size of the program. So we go through and replace each $\kwa{LJump}$ with a regular $\kwa{Jump}$; each $\kwa{LJumpEqZ}$ with a regular $\kwa{JumpEqZ}$; and each $\kwa{Label}$ with a $\kwa{NoOp}$ (you need to keep the $\kwa{NoOp}$ instructions in to keep the length of the program the same). \\

\noindent
What this means is the final code will have $\textbf{no symbolic jumps}$. Symbolic jumps exist only to help us during the translation stage. By the end they're all converted to regular jumps and no-ops. \\


\section{Translating If-Statements, Revisited}

Recall the program from before.

\begin{lstlisting}
if (0 < 1) then { x := 1 } else { x := 0 }
\end{lstlisting}

\noindent
On our first pass through the AST, we would translate the if-statement into the below stack-code:

\begin{lstlisting}
LoadI 0
LoadI 1
BinOp LessThan
LJumpEQ false_branch
LoadI 1
Store x
LJump exit
Label false_branch
LoadI 0
Store x
Label exit
\end{lstlisting}

\noindent
After generating code for the whole program, we would then go through and replace each $\kwa{LJump}$ with the appropriate $\kwa{Jump}$, and replace each $\kwa{Label}$ with a $\kwa{NoOp}$. The code above would be turned into the following final program.

\begin{lstlisting}
LoadI 0
LoadI 1
BinOp LessThan
JumpEqZ 8
LoadI 1
Store x
Jump 11
NoOp
LoadI 0
Store x
NoOp
\end{lstlisting}

\noindent
If we used $\kwa{false\_\_label}$ and $\kwa{exit}$ for every if-statement we'd run into a problem when turning symbolic jumps into regular jumps. Each if-statement needs to use a new pair of labels. We can this by using numbers to identify labels. During neighbours we keep track of which numbers are being used, perhaps with a counter. When we come to generate code for an if-statement, we generate two new labels for our own use (and increment the counter twice). \\

\noindent
The new strategy for generating code is as follows:

\begin{enumerate}
	\item Translate all statements using symbolic jumps.
	\item Replace all $\kwa{LJump}$s with regular $\kwa{Jump}$s; replace all $\kwa{Label}$s with $\kwa{NoOp}$s.
\end{enumerate}

\noindent
The new strategy for generating if-statements is as follows:

\begin{enumerate}
	\item Generate two fresh labels $\kwa{i}$ and $\kwa{j}$ and increment label counter by 2
	\item Translate the condition
	\item Add an $\kwa{LJumpEqZ~i}$ instruction
	\item Translate true branch
	\item Add an $\kwa{LJump~j}$ instruction
	\item Add a $\kwa{Label~i}$ instruction
	\item Translate false branch
	\item Add a $\kwa{Label~j}$ instruction
\end{enumerate}

\section{Case Expressions}

\noindent
The logic for executing $\kwa{BinOp}$ operations given to you in $\kwa{Straight.lhs}$ is as below.

\begin{lstlisting}[language=Haskell]
exec' (BinOp op)  (x:y:stack, store) = (z:stack, store)
    where z = apply op x y
    
apply :: Op -> Int -> Int -> Int
apply Plus x y = x+y 
apply Minus x y = x-y
apply Times x y = x*y
apply Div x y = x `div` y
\end{lstlisting}

An alternative way to implement this is using a $\kwa{case}$ expression.

\begin{lstlisting}[language=Haskell]
exec' (BinOp op) (x:y:stack, store) = (z:stack, store)
    where z = case op of
                  Plus $\rightarrow$ x + y
                  Minus $\rightarrow$ x - y
                  Times $\rightarrow$ x * y
                  Div $\rightarrow$ x `div` y
\end{lstlisting}

\noindent
This lets you pattern-match in the middle of an expression. E.g.

\begin{lstlisting}[language=Haskell]
let x = doSomething arg1 arg1
 in case x of
        firstPattern $\rightarrow$ firstAction
        secondPattern $\rightarrow$ secondAction
\end{lstlisting}

\noindent
If the runtime cannot match an argument to any of the given patterns an error is thrown.


\end{document}









